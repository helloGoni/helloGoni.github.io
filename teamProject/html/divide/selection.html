<!DOCTYPE html>
<head>
		<meta charset="utf-8">
		<link rel="stylesheet" href="../../css/frameStyle.css"> <!-- 모든 알고리즘 문서에 대하여 해당 stylesheet로 통일. -->
	</head>

	<body id="bg">
		<h1>선택 문제<span>Selection</span></h1>
		<article>
			<div>
			<b>선택 문제</b>(Selection)는 n개의 숫자들 중에서 k번째로 작은 숫자를 찾는 문제이다. 선택 문제는 숫자 찾기 문제이므로 임의의 숫자를 효율적으로 찾는 <b>이진탐색</b>에서
			아이디어를 가져 올 수 있다. 피봇을 선택하여 Small group과 Large group으로 나눈 뒤, 피봇과 찾는 숫자의 크기를 비교해 찾아나갈 수 있다.<br>
			선택 알고리즘은 이진탐색과 매우 유사한 성격을 가지고 있다. 이 알고리즘들은 <b>부분문제들을 취합하는 과정이 별도로 필요 없는 공통점</b>도 가진다.

			</div>

			<div>
				<h3>의사 코드</h3>
				Selection(A,left,right,k)<br>
				입력: A[left]~A[right]와 k, 단, 1&lt;=k &lt;=|A|, |A|=right-left+1<br>
				출력: A[left]~A[right]에서 k번째 작은 원소
				<ol id="list1" type="1">
					<li>피봇을 A[left]~A[right]에서 랜덤하게 선택하고, 피봇과 A[left]의 자리를 바꾼 후, 피봇과 배열의 각 원소를 비교하여 피봇보다 작은 숫자는 A[left]~A[p-1]로 옮기고,
						피봇보다 큰 숫자는 A[p+1]~A[right]로 옮기며, 피봇은 A[p]에 놓는다.
					</li>
					<li>S = (p-1)-left+1 // S = Small group의 크기</li>
					<li>if ( k &lt;= S ) Selection(A,left,p-1,k)</li>
					<li>else if ( k = S + 1 ) return A[p]</li>
					<li>else Selection(A,p+1,right,k-S-1)</li>
				</ol>
			</div>

			<div>
				<h3>시간 복잡도</h3>
				피봇을 랜덤하게 정했을 때 좋은 분할이 될 확률은 1/2이므로 2회 호출마다 좋은 분할이 되므로 좋은 분할만 연속하여 이루어졌을 때만의 시간복잡도를 구해
				그 값에 2를 곱하면 평균 경우의 시간복잡도를 얻을 수 있다. 분할 후 큰 부분의 최대 크기는 (3/4n-1)이다. 왜냐하면 좋은 분할만 일어난다고 가정했기 때문이다.
				즉, 입력 크기가 n에서부터 3/4배로 연속적으로 감소되고, 평균 시간 복잡도는 O(n)이다.
				<br>따라서 Selection 알고리즘의 평균 경우 시간복잡도는 <b>O(n)</b> 이다.


			</div>
			<div>
				<h3>응용</h3>
				선택 알고리즘은 정렬을 하지 않고 k번째 작은 수를 선형 시간에 찾을 수 있게 해준다. 따라서 선택 알고리즘은 <b>데이터 분석을 위한 중앙값</b>을 찾는데 활용된다.
			</div>

		</article>

		<footer>

			<hr>
			<h3>출처</h3>
			양성봉, 『알기 쉬운 알고리즘』, 생능출판사, p67-74.
			
		</footer>

		<a href="divideIndex.html"><div id="fixedBtn1">Home</div></a>
		<a href="quick.html"><div id="fixedBtn2">◀ Prev</div></a>
		<a href="closestPair.html"><div id="fixedBtn3">Next ▶</div></a>
	</body>

</html>