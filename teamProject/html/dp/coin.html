<!DOCTYPE html>
<html>

	<head>
		<meta charset="utf-8">
		<link rel="stylesheet" href="../../css/frameStyle.css"> <!-- 모든 알고리즘 문서에 대하여 해당 stylesheet로 통일. -->
	</head>

	<body id="bg">
		<h1>동전 거스름돈 문제<span>CoinChange</span></h1>
		<article>
			<div>
			<b>동전 거스름돈</b>(Coin Change) 문제의 경우 그리디 알고리즘을 이용하여 대부분의 문제를 해결할 수 있었으나, 해결하지 못하는 경우도 있다. 동적 계획법을 통해 동전 거스름돈 문제를 해결하면 항상 최적해를 얻는다.<br><br>

			배낭 문제에서 아이디어를 얻으면, 알고리즘을 쉽게 설계할 수 있다.<br><br>

			거스름돈을 배낭의 용량으로 동전을 물건이라고 생각할 때, 1원을 거슬러받을 때 사용되는 최소 동전 수 C[1], 2원을 거슬러받을 때 사용되는 최소 동전 수 C[2], n원을 거슬러받을 때 사용되는 최소 동전 수 C[n]의 방식으로 설정할 수 있다.<br><br>

			또한, k원짜리 동전이 거스름돈 j원에 필요하면 (j-k)원의 해 + 1를 추가하고, 이를 모든 동전에 대해 반복하여, 가장 작은 값을 C[j]에 넣는다. 이러한 방식을 최종적으로 거스름돈이 n이 될 때까지 반복한다면 C[n]에 동전의 최솟값이 담기게 된다.
			</div>

			<div>
				<h3>의사 코드</h3>
				입력: 거스름돈 n원, k개의 동전 액면, d<sub>1</sub> > d<sub>2</sub> ... d<sub>n</sub> > 1<br>
				출력: C[n]
				<ol id="list1" type="1">
					<li>for i = 1 to n  C[i] = ∞<li>
					<li>C[0] = 0<li>
					<li>for j = 1 to n { <li>
					<li>&nbsp;for i = 1 to k { </li>
					<li>&nbsp;&nbsp;if((d<sub>i</sub> <= j) and (C[j-d<sub>i</sub>]+1 < C[j]))</li>
					<li>&nbsp;&nbsp;&nbsp;C[j]=C[j-d<sub>i</sub>]+1 }}</li>
					<li>return C[n]<li>
				</ol>
			</div>

			<div>
				<h3>시간 복잡도</h3>
				거스름돈 j가 1원 부터 n원까지 변하며, 각각의 j에 대해서 최악의 경우 모든 동전 k개를 1번씩 고려하므로 O(nK)이다.
			</div>

		</article>

		<footer>
			<hr>
			<h3>출처</h3>
			양성봉, 『알기 쉬운 알고리즘』, 생능출판사, p201-212.
		</footer>

		<a href="dpIndex.html"><div id="fixedBtn1">Home</div></a>
		<a href="knapsack.html"><div id="fixedBtn2">◀ Prev</div></a>
		<a href="javascript:alert('다음 문서가 존재하지 않습니다.')"><div id="fixedBtn3">Next ▶</div></a>
	</body>

</html>